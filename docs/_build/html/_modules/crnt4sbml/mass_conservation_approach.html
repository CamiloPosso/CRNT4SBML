

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>crnt4sbml.mass_conservation_approach &mdash; CRNT4SBML 0.0.11 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> CRNT4SBML
          

          
          </a>

          
            
            
              <div class="version">
                0.0.11
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">CRNT4SBML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../detect_bistability.html">Steps for Detecting Bistability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../physiological_bounds.html">Creating Physiological Bounds</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../celldesigner_walkthrough.html">CellDesigner Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../basic_crnt.html">Low Deficiency Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../deficiency_walkthrough.html">Mass Conservation Approach Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../injectivity_walkthrough.html">Semi-diffusive Approach Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../general_app_walkthrough.html">General Approach Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../parallel_crnt4sbml.html">Parallel CRNT4SBML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../numerical_opt.html">Numerical Optimization Routine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../numerical_cont.html">Numerical Continuation Routine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../direct_simulation.html">Direct Simulation for the General Approach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../creating_eq_manifold.html">Creating the Equilibrium Manifold</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../confidence_level.html">Confidence Level Routine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generating_c_graphs.html">Generating Presentable C-graphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../more_examples.html">Further Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example_use.html">An Example User Case Scenario</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../zbibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CRNT4SBML</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>crnt4sbml.mass_conservation_approach</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for crnt4sbml.mass_conservation_approach</h1><div class="highlight"><pre>
<span></span>import os
import numpy
import sympy
import sympy.utilities.lambdify
import sys 
import time
import numpy.linalg
import itertools
import warnings
import math
from .bistability_finder import BistabilityFinder
from .bistability_analysis import BistabilityAnalysis

<div class="viewcode-block" id="MassConservationApproach"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach">[docs]</a>class MassConservationApproach:
    &quot;&quot;&quot;
    Class for constructing variables and methods needed for the mass conservation approach.
    &quot;&quot;&quot;
<div class="viewcode-block" id="MassConservationApproach.__init__"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.__init__">[docs]</a>    def __init__(self, cgraph, get_physiological_range):
        &quot;&quot;&quot;
        Initialization of the MassConservationApproach class.

        See also
        ---------
        crnt4sbml.CRNT.get_mass_conservation_approach()
        &quot;&quot;&quot;
        self.__cgraph = cgraph
        self.get_physiological_range = get_physiological_range

        if not all([i &lt;= 1 for i in self.__cgraph.get_number_of_terminal_strong_lc_per_lc()]):
            print(&quot;The network is not uniterminal!&quot;)
            sys.exit()

        if not self.__cgraph.get_dim_equilibrium_manifold() &gt; 0:
            print(&quot;# of species - rank(S) is not greater than zero!&quot;)
            print(&quot;The mass conservation approach cannot be ran!&quot;)
            sys.exit()

        # declare key fields
        self.__deficiency_pars = None
        self.__concentration_pars = None
        self.__reaction_pars = None 
        self.__W = None  # matrix
        self.__W_nullspace = None
        self.__H = None  # vector
        self.__G = None  # matrix
        self.__symbolic_objective_fun = None
        self.__concentration_vals = None
        self.__decision_vector_x = None
        self.__concentration_funs = None 
        self.__objective_fun_params = None
        self.__lambda_objective_fun = None 
        self.__important_info = &quot;&quot;
        self.__numpy_dtype = None
        self.__independent_odes = None
        self.__independent_species = None
        self.__comm = None
        self.__my_rank = None
        self.__num_cores = None

        # vars used frequently
        self.__N = len(self.__cgraph.get_species())
        self.__R = len(self.__cgraph.get_reactions())
        self.__species = self.__cgraph.get_species()
        self.__reactions = self.__cgraph.get_reactions()
        self.__delta = self.__cgraph.get_deficiency()
        self.__M = len(self.__cgraph.get_complexes())
        self.__ell = len(self.__cgraph.get_linkage_classes())
        self.__lambda = self.__cgraph.get_dim_equilibrium_manifold()
        self.__classification = self.__cgraph.get_network_dimensionality_classification()
        # compute necessary vectors and matrices
        self.__create_deficiency_pars()
        self.__create_concentration_pars()
        self.__create_reaction_pars()
        self.__create_w_matrix()
        self.__create_w_nullspace()
        self.__create_h_vector()
        self.__create_g_matrix()
        self.__create_symbolic_objective_fun()
        self.__create_decision_vector_x()
        self.__create_concentration_bounds_species()
        self.__create_concentration_lambda_fun()
        self.__create_objective_fun__lambda_fun()
        self.__create_g_matrix_lambda_fun()
        self.__create_dch_matrix_lambda_fun()</div>

    def __create_deficiency_pars(self):
        # creating a vector of the deficiency parameters
        # \alpha_1, ..., \alpha_\delta
        self.__deficiency_pars = [sympy.symbols(&#39;a&#39; + str(i + 1), real=True) for i
                                  in range(self.__delta)]

    def __create_concentration_pars(self):
        # putting the species in a list for more readable code
        self.__concentration_pars = [sympy.Symbol(self.__species[i], positive=True) for i in range(self.__N)]

    def __create_reaction_pars(self):
        self.__reaction_pars = [sympy.Symbol(self.__reactions[i], positive=True) for i in range(self.__R)]
        
    def __create_w_matrix(self):
        # concatenating Y and Lambda_T columnwise
        # to create [Y,Lambda_T]^T
        self.__W = self.__cgraph.get_y().col_join(self.__cgraph.get_lambda().T)

    def __create_w_nullspace(self):
        # Finding the null space of [Y,Lambda_T]^T,
        # i.e. \omega_i i=1,...,\delta
        self.__W_nullspace = self.__W.nullspace()

    def __create_h_vector(self):

        print(&quot;Creating Equilibrium Manifold ...&quot;)
        start = time.process_time()
        # creates the H vector in equation (10) by finding the linearly
        # independent rows of (9)
        # symbolic for of psi vector
        psi_symbol_vec = sympy.zeros(self.__M, 1)
        for i in range(self.__M):
            psi_symbol_vec[i] = sympy.Symbol(&#39;psi&#39; + str(i))

        # creating the right-hand side defined by
        # \sum_{i=1}^\delta \alpha_i \omega_i
        rhs = sympy.zeros(self.__M, 1)
        temp = sympy.zeros(self.__M, 1)
        for i in range(self.__delta):
            for j in range(self.__M):
                temp[j] = self.__deficiency_pars[i] * self.__W_nullspace[i][j]
            rhs += temp
        # creating H(c,\alpha,k) with rows that might
        # be linearly dependent
        temp_vec = self.__cgraph.get_a() * self.__cgraph.get_psi() - rhs
        temp_vec2 = self.__cgraph.get_a() * psi_symbol_vec - rhs

        # creating a matrix of coefficients for the variables
        # psi_1, ..., psi_M, alpha_1, ... alpha_delta
        variables = [sympy.Symbol(&#39;psi&#39; + str(i)) for i in range(self.__M)] + self.__deficiency_pars
        a, _ = sympy.linear_eq_to_matrix(temp_vec2, variables)
        temp_mat_2 = sympy.zeros(self.__M, self.__M + self.__delta)

        # preallocating the H vector
        self.__H = sympy.zeros(self.__M - self.__ell, 1)

        leng = self.__M - self.__ell - self.__delta
        comb = list(itertools.combinations(self.__concentration_pars, leng))
        # building the different possible independent variable sets
        indp_vars = []
        for i in comb:
            indp_vars.append(list(i)+self.__deficiency_pars)

        self.__indices_explored = []
        self.__counts_n_indices = []

        # continue loop until acceptable concentration solutions are found
        flag = True
        indicies_to_skip = []
        while flag:

            reordered_indices, chosen_index = self.__create_fixed_free_pars_and_reordered_ind(temp_vec, indicies_to_skip,
                                                                                              indp_vars)

            for i in range(self.__M):
                temp_mat_2[i, :] = a[reordered_indices[i], :]

            # gives vals which is the rows of temp_mat that are
            # independent from the others this allows us
            # to create H(c, \alpha, k)
            _, temp_vals = temp_mat_2.T.rref()
            vals = [reordered_indices[i] for i in temp_vals]

            # Filling the H vector with linearly independent rows
            for i in range(len(vals)):
                self.__H[i] = temp_vec[vals[i]]

            flag = self.__create_concentration_values()

            if flag:
                indicies_to_skip.append(chosen_index)

            nn = len(self.__concentration_pars)
            rr = self.__M - self.__ell - self.__delta
            if len(indicies_to_skip) == math.factorial(nn) / (math.factorial(rr) * math.factorial(nn-rr)):
                flag = False
                raise Exception(&quot;An analytic solution for the concentrations could not be found. The mass conservation approach connot be used.&quot;)

        end = time.process_time()
        print(&quot;Elapsed time for creating Equilibrium Manifold: &quot; + str(end - start))

    def __create_fixed_free_pars_and_reordered_ind(self, temp_vec, indicies_to_skip, indp_vars):

        # determining the different combinations of concentrations
        # present in the independent variables once the deficiency
        # parameters are chosen to be independent
        leng = self.__M - self.__ell - self.__delta

        # finding the number of linear equations produced by a
        # given independent variable set
        for jj in range(len(indp_vars)):

            if jj not in indicies_to_skip and jj not in self.__indices_explored:

                num_lin_entries = [self.__is_linear(temp_vec[j], indp_vars[jj][0:leng]) for j in
                                   range(temp_vec.shape[0])].count(True)

                self.__counts_n_indices.append([num_lin_entries, jj])
                self.__indices_explored.append(jj)

                # if all of the equations are linear stop,
                # prevents long run times
                if num_lin_entries == self.__M:
                    break

        # picking the independent variable set that has the most
        # amount of linear equations
        max_element = self.__max_element(indicies_to_skip)
        chosen_index = max_element[1]

        self.__fixed_pars = indp_vars[chosen_index]
        self.__free_pars = [i for i in self.__deficiency_pars + self.__concentration_pars if i not in self.__fixed_pars]

        # rearranging A s.t. the linear equations are in the top
        # rows, this is for convenience and easier solutions for
        # the independent variables
        out = [self.__is_linear(temp_vec[j], indp_vars[chosen_index]) for j in range(temp_vec.shape[0])]
        reordered_indices = [i for i, x in enumerate(out) if x] + [i for i, x in enumerate(out) if not x]

        return reordered_indices, max_element[1]

    def __max_element(self, indicies_to_skip):

        temp = self.__counts_n_indices[:]

        for i in self.__counts_n_indices:

            if i[1] in indicies_to_skip:
                temp.remove(i)

        return max(temp, key=lambda item: item[0])

    # routine that determines if a sympy expression is jointly
    # linear with respect to a given set of variables. This
    # test is conducted by seeing if the second order derivatives
    # are zero.
    def __is_linear(self, expr, variables):

        for x in variables:
            for y in variables:
                try: 
                    if not sympy.Eq(sympy.diff(expr, x, y), 0):
                        return False
                except TypeError:
                    return False
        return True

    def __create_g_matrix(self):

        # creating the matrix DCH which is the jacobian of
        # the vector H with respect to the concentration vector
        self.__DCH = self.__H.jacobian(sympy.Matrix(self.__concentration_pars))

        # creation of the matrix dah which is the jacobian of
        # the vector H with respect to the deficiency param vector
        dah = self.__H.jacobian(sympy.Matrix(self.__deficiency_pars))
        # creation of the matrix daw which is the jacobian of
        # the vector W with respect to the deficiency param vector
        # However, as given in page 11, D_\alpha W = 0, thus
        # just a zero matrix of size \lambda by \delta
        daw = sympy.zeros(self.__lambda, self.__delta)
        # creating the upper half of the matrix G i.e. [DCH dah]
        g_upper = self.__DCH.row_join(dah)
        # creating the lower half of the matrix G i.e. [DCW daw]
        # Note that D_c W = B^T
        g_lower = self.__cgraph.get_b().row_join(daw)
        # putting the upper and lower half of the matrix together
        # this forms the full G(c, \alpha, k) matrix
        self.__G = g_upper.col_join(g_lower)

    def __create_symbolic_objective_fun(self):
        # computing the simplified version of the objective
        # function defined as: det(G(c, \alpha, k))^2
        self.__symbolic_objective_fun = (self.__G.det(method=&#39;lu&#39;))**2

    def __create_concentration_values(self):

        # Putting the concentrations in terms of the kinetic
        # constants and deficiency parameters using the H
        # vector of the equilibrium manifold
        try:
            temp_solution_tuple = sympy.solve(self.__H, self.__fixed_pars, dict=True)
        except Exception as e:
            temp_solution_tuple = []

        if not temp_solution_tuple:
            flag = True
        else:
            if isinstance(temp_solution_tuple, dict):
                self.__concentration_vals = []
                for i in self.__concentration_pars:
                    if i in temp_solution_tuple:
                        self.__concentration_vals.append(temp_solution_tuple[i])
                    else:
                        self.__concentration_vals.append(i)
            # multiple solutions found
            else:
                solution_list = []
                for i in temp_solution_tuple:
                    temp = []
                    for j in self.__concentration_pars:
                        if j in i:
                            temp.append(i[j])
                        else:
                            temp.append(j)
                    solution_list.append(temp)
                self.__concentration_vals = self.__pick_solution_set(solution_list)    ########### TODO: do same for if statement make flag True if negative

            for i in self.__concentration_vals:

                deficiency_pars_found = [i.count(j) &gt; 0 for j in self.__deficiency_pars + self.__fixed_pars]

                if True in deficiency_pars_found:
                    flag = True
                    break
                else:
                    flag = False

        return flag

    # chose solution set that is most likely to produce
    # positive concentrations
    def __pick_solution_set(self, solution_list):
        positivity = []
        for i in solution_list:
            temp = []
            for j in i:
                temp.append(j.is_positive)
            positivity.append(temp)

        verdict = []
        for i in positivity:
            if False not in i:
                if all(i):
                    # positive concentrations achieved
                    verdict.append(&quot;P&quot;)
                elif True in i:
                    # positive concentrations and Nones
                    verdict.append(&quot;PU&quot;)
                else:
                    # All entries are None
                    verdict.append(&quot;U&quot;)
            else:
                # negative concentration given
                verdict.append(&quot;N&quot;)

        if &quot;P&quot; in verdict:
            indx = verdict.index(&quot;P&quot;)
            choice = solution_list[indx]
        elif &quot;PU&quot; in verdict:
            indx = verdict.index(&quot;PU&quot;)
            choice = solution_list[indx]
        elif &quot;U&quot; in verdict:
            indx = verdict.index(&quot;U&quot;)
            choice = solution_list[indx]
        else:
            print(&quot;Solution chosen produces all negative concentrations!&quot;)
            sys.exit()

        return choice 

    def __create_decision_vector_x(self):
        # if it is a proper/over-dimensioned network let
        # xvec = (k_1 , ... k_R, alpha_1, ... alpha_lambda)
        # else let
        # xvec = (k_1 , ... k_R, alpha_1, ... alpha_delta,
        # c_1, ..., c_(lambda - delta))
        self.__decision_vector_x = self.__reaction_pars + self.__free_pars

        self.__d_len = len(self.__decision_vector_x)

    def __create_concentration_bounds_species(self):
        self.__concentration_bounds_species = [i for i in self.__concentration_pars
                                               if i not in self.__decision_vector_x]

    def __create_concentration_lambda_fun(self):
        self.__concentration_funs = []
        for i in range(self.__N):
            self.__concentration_funs += [sympy.utilities.lambdify(self.__decision_vector_x,
                                                                   self.__concentration_vals[i])]

    def __create_objective_fun__lambda_fun(self):
        self.__objective_fun_params = self.__reaction_pars + self.__concentration_pars
        self.__lambda_objective_fun = sympy.utilities.lambdify(self.__objective_fun_params,
                                                               self.__symbolic_objective_fun)

    def __create_g_matrix_lambda_fun(self):
        self.__lambda_G_matrix = sympy.utilities.lambdify(self.__objective_fun_params, self.__G)
        
    def __create_dch_matrix_lambda_fun(self):
        self.__lambda_DCH_matrix = sympy.utilities.lambdify(self.__objective_fun_params, self.__DCH)

    # getters
<div class="viewcode-block" id="MassConservationApproach.get_w_matrix"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_w_matrix">[docs]</a>    def get_w_matrix(self):
        &quot;&quot;&quot;
        Returns SymPy matrix :math:`[Y, \Lambda^T]^T`, which we call the W matrix.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; import sympy
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; sympy.pprint(approach.get_w_matrix())
            ⎡1  0  0  0  0  1  1  0  0⎤
            ⎢                         ⎥
            ⎢1  0  1  0  0  0  0  0  0⎥
            ⎢                         ⎥
            ⎢0  1  0  0  0  0  0  0  0⎥
            ⎢                         ⎥
            ⎢0  0  1  1  0  0  1  0  2⎥
            ⎢                         ⎥
            ⎢0  0  0  1  0  1  0  0  0⎥
            ⎢                         ⎥
            ⎢0  0  0  0  1  0  0  0  0⎥
            ⎢                         ⎥
            ⎢0  0  0  0  0  0  0  1  0⎥
            ⎢                         ⎥
            ⎢1  1  1  0  0  0  0  0  0⎥
            ⎢                         ⎥
            ⎢0  0  0  1  1  1  0  0  0⎥
            ⎢                         ⎥
            ⎣0  0  0  0  0  0  1  1  1⎦
        &quot;&quot;&quot;
        return self.__W</div>

<div class="viewcode-block" id="MassConservationApproach.get_w_nullspace"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_w_nullspace">[docs]</a>    def get_w_nullspace(self):
        &quot;&quot;&quot;
        Returns a list of SymPy column vectors representing :math:`Null([Y, \Lambda^T]^T)`.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; import sympy
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; sympy.pprint(approach.get_w_nullspace())
            ⎡⎡-1⎤  ⎡1 ⎤⎤
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎢⎢0 ⎥  ⎢0 ⎥⎥
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎢⎢1 ⎥  ⎢-1⎥⎥
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎢⎢-1⎥  ⎢0 ⎥⎥
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎢⎢0 ⎥, ⎢0 ⎥⎥
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎢⎢1 ⎥  ⎢0 ⎥⎥
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎢⎢0 ⎥  ⎢-1⎥⎥
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎢⎢0 ⎥  ⎢0 ⎥⎥
            ⎢⎢  ⎥  ⎢  ⎥⎥
            ⎣⎣0 ⎦  ⎣1 ⎦⎦
        &quot;&quot;&quot;
        return self.__W_nullspace</div>

<div class="viewcode-block" id="MassConservationApproach.get_h_vector"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_h_vector">[docs]</a>    def get_h_vector(self):
        &quot;&quot;&quot;
        Returns a SymPy matrix representing the equilibrium manifold.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; import sympy
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; sympy.pprint(approach.get_h_vector())
            ⎡a₁ - a₂ - re₁⋅s₁⋅s₂ + re1r⋅s₃⎤
            ⎢                             ⎥
            ⎢re₁⋅s₁⋅s₂ + s₃⋅(-re1r - re₂) ⎥
            ⎢                             ⎥
            ⎢  a₁ - re₃⋅s₆⋅s₇ + re3r⋅s₁₆  ⎥
            ⎢                             ⎥
            ⎢re₃⋅s₆⋅s₇ + s₁₆⋅(-re3r - re₄)⎥
            ⎢                             ⎥
            ⎢  a₂ - re₅⋅s₁⋅s₆ + re5r⋅s₁₅  ⎥
            ⎢                             ⎥
            ⎣re₅⋅s₁⋅s₆ + s₁₅⋅(-re5r - re₆)⎦
        &quot;&quot;&quot;
        return self.__H</div>

<div class="viewcode-block" id="MassConservationApproach.get_g_matrix"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_g_matrix">[docs]</a>    def get_g_matrix(self):
        &quot;&quot;&quot;
        Returns a SymPy matrix representing the G matrix of the defined optimization problem.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; import sympy
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; sympy.pprint(approach.get_g_matrix())
            ⎡-re₁⋅s₂  -re₁⋅s₁     re1r         0        0          0            0       1  -1⎤
            ⎢                                                                                ⎥
            ⎢re₁⋅s₂   re₁⋅s₁   -re1r - re₂     0        0          0            0       0  0 ⎥
            ⎢                                                                                ⎥
            ⎢   0        0          0       -re₃⋅s₇  -re₃⋅s₆     re3r           0       1  0 ⎥
            ⎢                                                                                ⎥
            ⎢   0        0          0       re₃⋅s₇   re₃⋅s₆   -re3r - re₄       0       0  0 ⎥
            ⎢                                                                                ⎥
            ⎢-re₅⋅s₆     0          0       -re₅⋅s₁     0          0          re5r      0  1 ⎥
            ⎢                                                                                ⎥
            ⎢re₅⋅s₆      0          0       re₅⋅s₁      0          0       -re5r - re₆  0  0 ⎥
            ⎢                                                                                ⎥
            ⎢   0        0          0          0       1.0        1.0           0       0  0 ⎥
            ⎢                                                                                ⎥
            ⎢   0       1.0        1.0         0        0          0            0       0  0 ⎥
            ⎢                                                                                ⎥
            ⎣  1.0       0         1.0        1.0       0         1.0          2.0      0  0 ⎦
        &quot;&quot;&quot;
        return self.__G</div>

<div class="viewcode-block" id="MassConservationApproach.get_dch_matrix"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_dch_matrix">[docs]</a>    def get_dch_matrix(self):
        &quot;&quot;&quot;
        Returns a SymPy matrix representing the Jacobian of the equilibrium manifold with respect to the species.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; import sympy
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; sympy.pprint(approach.get_dch_matrix())
            ⎡-re₁⋅s₂  -re₁⋅s₁     re1r         0        0          0            0     ⎤
            ⎢                                                                         ⎥
            ⎢re₁⋅s₂   re₁⋅s₁   -re1r - re₂     0        0          0            0     ⎥
            ⎢                                                                         ⎥
            ⎢   0        0          0       -re₃⋅s₇  -re₃⋅s₆     re3r           0     ⎥
            ⎢                                                                         ⎥
            ⎢   0        0          0       re₃⋅s₇   re₃⋅s₆   -re3r - re₄       0     ⎥
            ⎢                                                                         ⎥
            ⎢-re₅⋅s₆     0          0       -re₅⋅s₁     0          0          re5r    ⎥
            ⎢                                                                         ⎥
            ⎣re₅⋅s₆      0          0       re₅⋅s₁      0          0       -re5r - re₆⎦
        &quot;&quot;&quot;
        return self.__DCH</div>

<div class="viewcode-block" id="MassConservationApproach.get_lambda_g_matrix"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_lambda_g_matrix">[docs]</a>    def get_lambda_g_matrix(self):
        &quot;&quot;&quot;
        Returns a lambda function representation of the G matrix. Here the arguments of the lambda function are given
        by the values provided by :func:`crnt4sbml.MassConservationApproach.get_objective_fun_params`.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_lambda_g_matrix())
            &lt;function _lambdifygenerated at 0x13248ac80&gt;
        &quot;&quot;&quot;
        return self.__lambda_G_matrix</div>

<div class="viewcode-block" id="MassConservationApproach.get_lambda_dch_matrix"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_lambda_dch_matrix">[docs]</a>    def get_lambda_dch_matrix(self):
        &quot;&quot;&quot;
        Returns a lambda function representation of the Jacobian of the equilibrium manifold matrix. Here the
        arguments of the lambda function are given by the values provided by
        :func:`crnt4sbml.MassConservationApproach.get_objective_fun_params`.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_lambda_dch_matrix())
            &lt;function _lambdifygenerated at 0x131a06ea0&gt;
        &quot;&quot;&quot;
        return self.__lambda_DCH_matrix</div>

<div class="viewcode-block" id="MassConservationApproach.get_symbolic_objective_fun"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_symbolic_objective_fun">[docs]</a>    def get_symbolic_objective_fun(self):
        &quot;&quot;&quot;
        Returns SymPy expression for the objective function of the optimization problem. This is the determinant of the
        G matrix squared.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_symbolic_objective_fun())
            1.0*re1**2*re2**2*re3**2*re4**2*re5**2*re6**2*s1**2*s6**2*s7**2*((1.0*s2/s7 - 1.0*s2*(-re3r - re4)/
            (re3*s6*s7))/re4 + (1.0 + 1.0*re1r/(re1*s1))/re2 + 1.0/(re1*s1))**2*(-((1.0*s6*(-1.0*s1/s6 + 1.0)/s7 +
            1.0 - (-re3r - re4)*(-1.0*s1/s6 + 1.0)/(re3*s7))/re4 + 1.0/re2)*(-1.0*re5r*s2/(re5*re6*s1*s6) -
            1.0*s2*(1 + re5*s6/(re1*s2))/(re5*s1*s6) - (1.0 + 1.0*re1r/(re1*s1))/re2)/((1.0*s2/s7 - 1.0*s2*
            (-re3r - re4)/(re3*s6*s7))/re4 + (1.0 + 1.0*re1r/(re1*s1))/re2 + 1.0/(re1*s1)) + (2.0 + 1.0*re5r/(re5*s6))/
            re6 + 1.0*(1 + re5*s6/(re1*s2))/(re5*s6) - 1.0/re2 - 1.0/(re1*s2))**2
        &quot;&quot;&quot;
        return self.__symbolic_objective_fun</div>

<div class="viewcode-block" id="MassConservationApproach.get_lambda_objective_fun"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_lambda_objective_fun">[docs]</a>    def get_lambda_objective_fun(self):
        &quot;&quot;&quot;
        Returns a lambda function representation of the objective function of the optimization problem. Here the
        arguments of the lambda function are given by the values provided by
        :func:`crnt4sbml.MassConservationApproach.get_objective_fun_params`.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_lambda_objective_fun())
            &lt;function _lambdifygenerated at 0x12f6f7ea0&gt;
        &quot;&quot;&quot;
        return self.__lambda_objective_fun</div>

<div class="viewcode-block" id="MassConservationApproach.get_concentration_vals"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_concentration_vals">[docs]</a>    def get_concentration_vals(self):
        &quot;&quot;&quot;
        Returns a list of SymPy expressions representing the species in terms of those variables present in the decision
        vector. The order is that established in :func:`crnt4sbml.Cgraph.get_species`. Note that if only a single
        species is provided as an element in the list, this means the species is a free variable.

        See also
        ---------
        crnt4sbml.MassConservationApproach.get_concentration_solutions


        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_concentration_vals())
            [s15*(re5r + re6)/(re5*s6), s2, re1*s15*s2*(re5r + re6)/(re5*s6*(re1r + re2)), s6,
            -s15*(re5*re5r*s6*(re1r + re2)*(re3r + re4) - (re5r + re6)*(-re1*re1r*re3r*s2 - re1*re1r*re4*s2 +
            re1*re3r*s2*(re1r + re2) + re1*re4*s2*(re1r + re2) + re5*s6*(re1r + re2)*(re3r + re4)))/(re3*re4*re5*s6**2*
            (re1r + re2)), s15*(re1*re2*re5r*s2 + re1*re2*re6*s2 + re1r*re5*re6*s6 + re2*re5*re6*s6)/(re4*re5*s6*(re1r + re2)), s15]
        &quot;&quot;&quot;
        return self.__concentration_vals</div>

<div class="viewcode-block" id="MassConservationApproach.get_decision_vector"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_decision_vector">[docs]</a>    def get_decision_vector(self):
        &quot;&quot;&quot;
        Returns a list of SymPy variables that represent the decision vector of the optimization problem.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_decision_vector())
            [re1, re1r, re2, re3, re3r, re4, re5, re5r, re6, s2, s6, s15]
        &quot;&quot;&quot;
        return self.__decision_vector_x</div>

<div class="viewcode-block" id="MassConservationApproach.get_concentration_bounds_species"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_concentration_bounds_species">[docs]</a>    def get_concentration_bounds_species(self):
        &quot;&quot;&quot;
        Returns a list of SymPy variables that represents the order of species for the concentration bounds provided
        to :func:`crnt4sbml.MassConservationApproach.run_optimization`.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_concentration_bounds_species())
            [s1, s3, s7, s16]
        &quot;&quot;&quot;
        return self.__concentration_bounds_species</div>

<div class="viewcode-block" id="MassConservationApproach.get_concentration_funs"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_concentration_funs">[docs]</a>    def get_concentration_funs(self):
        &quot;&quot;&quot;
        Returns a list of lambda functions representing each of the species. Here the species are those expressions
        provided by :func:`crnt4sbml.MassConservationApproach.get_concentration_vals` where the arguments of each
        lambda function is provided by :func:`crnt4sbml.MassConservationApproach.get_decision_vector`.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_concentration_funs())
            [&lt;function _lambdifygenerated at 0x135f8b4d0&gt;, &lt;function _lambdifygenerated at 0x135f72050&gt;,
            &lt;function _lambdifygenerated at 0x135f728c0&gt;, &lt;function _lambdifygenerated at 0x135f725f0&gt;,
            &lt;function _lambdifygenerated at 0x135f5f830&gt;, &lt;function _lambdifygenerated at 0x135fa0170&gt;,
            &lt;function _lambdifygenerated at 0x135fa04d0&gt;]
        &quot;&quot;&quot;
        return self.__concentration_funs</div>

<div class="viewcode-block" id="MassConservationApproach.get_objective_fun_params"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_objective_fun_params">[docs]</a>    def get_objective_fun_params(self):
        &quot;&quot;&quot;
        Returns a list of SymPy variables that represent those variables that may be contained in the G matrix, Jacobian
        of the equilibrium manifold with respect to the species, or objective function.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_objective_fun_params())
            [re1, re1r, re2, re3, re3r, re4, re5, re5r, re6, s1, s2, s3, s6, s7, s16, s15]
        &quot;&quot;&quot;
        return self.__objective_fun_params</div>

<div class="viewcode-block" id="MassConservationApproach.get_conservation_laws"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_conservation_laws">[docs]</a>    def get_conservation_laws(self):
        &quot;&quot;&quot;
        Returns a string representation of the conservation laws. Here the values on the left hand side of each equation
        are the constants of the conservation laws.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_conservation_laws())
            C1 = 1.0*s16 + 1.0*s7
            C2 = 1.0*s2 + 1.0*s3
            C3 = 1.0*s1 + 2.0*s15 + 1.0*s16 + 1.0*s3 + 1.0*s6
        &quot;&quot;&quot;
        rhs = self.__cgraph.get_b() * sympy.Matrix([self.__concentration_pars]).T
        laws = &quot;&quot;
        for i in range(rhs.shape[0]):
            laws += &#39;C&#39; + str(i+1) + &#39; = &#39; + str(rhs[i]) + &#39;\n&#39;
        
        return laws</div>

<div class="viewcode-block" id="MassConservationApproach.get_concentration_solutions"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_concentration_solutions">[docs]</a>    def get_concentration_solutions(self):
        &quot;&quot;&quot;
        Returns a more readable string representation of the species defined in terms of the decision vector.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; print(approach.get_concentration_solutions())
            s1 = s15*(re5r + re6)/(re5*s6)
            s2 = s2
            s3 = re1*s15*s2*(re5r + re6)/(re5*s6*(re1r + re2))
            s6 = s6
            s7 = -s15*(re5*re5r*s6*(re1r + re2)*(re3r + re4) - (re5r + re6)*(-re1*re1r*re3r*s2 - re1*re1r*re4*s2 + re1*re3r*s2*(re1r + re2) + re1*re4*s2*(re1r + re2) + re5*s6*(re1r + re2)*(re3r + re4)))/(re3*re4*re5*s6**2*(re1r + re2))
            s16 = s15*(re1*re2*re5r*s2 + re1*re2*re6*s2 + re1r*re5*re6*s6 + re2*re5*re6*s6)/(re4*re5*s6*(re1r + re2))
            s15 = s15
        &quot;&quot;&quot;
        sols = &quot;&quot;
        for i in range(self.__N):
            sols += self.__species[i] + &#39; = &#39; + str(self.__concentration_vals[i]) + &#39;\n&#39;            

        return sols</div>

<div class="viewcode-block" id="MassConservationApproach.get_independent_odes"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_independent_odes">[docs]</a>    def get_independent_odes(self):
        &quot;&quot;&quot;
        Returns a SymPy Matrix where the rows represent the independent ODEs used in the numerical continuation routine. Here
        the entries of the list correspond to the time derivatives of the corresponding species provided by
        :func:`crnt4sbml.MassConservationApproach.get_independent_species`. Note that the independent ODEs created are
        based on the species chosen for the numerical continuation. Thus, the continuation routine needs to be ran
        first. If this function is called before the numerical continuation routine then None will be returned.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/sbml_file.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
        &gt;&gt;&gt; multistable_param_ind = approach.run_greedy_continuity_analysis(species=&quot;species&quot;, parameters=params_for_global_min,
                                                                            auto_parameters={&#39;PrincipalContinuationParameter&#39;: &quot;PCP&quot;})
        &gt;&gt;&gt; odes = approach.get_independent_odes()
        &quot;&quot;&quot;

        return self.__independent_odes</div>

<div class="viewcode-block" id="MassConservationApproach.get_independent_species"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_independent_species">[docs]</a>    def get_independent_species(self):
        &quot;&quot;&quot;
        Returns a list of SymPy representations of the independent species used in the numerical continuation routine.
        Note that the independent species created are based on the species chosen for the numerical continuation. Thus,
        the continuation routine needs to be ran first. If this function is called before the numerical continuation
        routine then None will be returned.

        Example
        --------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/sbml_file.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
        &gt;&gt;&gt; multistable_param_ind = approach.run_greedy_continuity_analysis(species=&quot;species&quot;, parameters=params_for_global_min,
                                                                            auto_parameters={&#39;PrincipalContinuationParameter&#39;: &quot;PCP&quot;})
        &gt;&gt;&gt; species = approach.get_independent_species()
        &quot;&quot;&quot;

        return self.__independent_species</div>

<div class="viewcode-block" id="MassConservationApproach.get_optimization_bounds"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.get_optimization_bounds">[docs]</a>    def get_optimization_bounds(self):
        &quot;&quot;&quot;
        Builds all of the necessary physiological bounds for the optimization routine.
        :download:`Fig1Ci.xml &lt;../../sbml_files/Fig1Ci.xml&gt;` for the provided
        example.

        Returns
        --------
        bounds: list of tuples
            List of tuples defining the upper and lower bounds for the decision vector variables based on physiological
            ranges.
        concentration_bounds: list of tuples
            List of tuples defining the upper and lower bounds for those concentrations not in the decision vector
            based on physiological ranges.

        Examples
        ---------
        &gt;&gt;&gt; import crnt4sbml
        &gt;&gt;&gt; network = crnt4sbml.CRNT(&quot;path/to/Fig1Ci.xml&quot;)
        &gt;&gt;&gt; approach = network.get_mass_conservation_approach()
            Creating Equilibrium Manifold ...
            Elapsed time for creating Equilibrium Manifold: 2.060944

        &gt;&gt;&gt; bounds, concentration_bounds = approach.get_optimization_bounds()
        &gt;&gt;&gt; print(bounds)
            [(1e-08, 0.0001), (1e-05, 0.001), (0.001, 1.0), (1e-08, 0.0001), (1e-05, 0.001), (0.001, 1.0),
            (1e-08, 0.0001), (1e-05, 0.001), (0.001, 1.0), (0.5, 500000.0), (0.5, 500000.0), (0.5, 500000.0)]

        &gt;&gt;&gt; print(concentration_bounds)
            [(0.5, 500000.0), (0.5, 500000.0), (0.5, 500000.0), (0.5, 500000.0)]
        &quot;&quot;&quot;

        graph_edges = self.__cgraph.get_g_edges()
        dec_vec_var_def = []
        for i in self.get_decision_vector():

            if i in self.__concentration_pars:
                dec_vec_var_def.append(&quot;concentration&quot;)
            elif i in self.__reaction_pars:

                ind = self.__reaction_pars.index(i)
                reaction = graph_edges[ind]

                reaction_type = self.__cgraph.get_graph().edges[reaction][&#39;type&#39;]
                dec_vec_var_def.append(reaction_type)

                if reaction_type is None:
                    output_statement = &quot;The reaction type of reaction &quot; + self.__cgraph.get_graph().edges[reaction][&#39;label&#39;] \
                                       + &quot; could not be identified as it does not fit any biological criteria &quot; +\
                                       &quot;established. \n&quot; + &quot;You must enter bounds manually for this reaction! \n&quot;
                    print(output_statement)

        concentration_bounds = [self.get_physiological_range(&quot;concentration&quot;)]*len(self.get_concentration_bounds_species())

        bounds = [self.get_physiological_range(i) for i in dec_vec_var_def]

        return bounds, concentration_bounds</div>

<div class="viewcode-block" id="MassConservationApproach.run_optimization"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.run_optimization">[docs]</a>    def run_optimization(self, bounds=None, iterations=10, sys_min_val=numpy.finfo(float).eps, seed=0, print_flag=False,
                         numpy_dtype=numpy.float64, concentration_bounds=None, confidence_level_flag=False,
                         change_in_rel_error=1e-2):
        &quot;&quot;&quot;
        Function for running the optimization problem for the mass conservation approach.

        Parameters
        -----------
            bounds: list of tuples
                A list defining the lower and upper bounds for each variable in the decision vector. Here the reactions
                are allowed to be set to a single value.
            iterations: int
                The number of iterations to run the feasible point method.
            sys_min_val: float
                The value that should be considered zero for the optimization problem.
            seed: int
                Seed for the random number generator. None should be used if a random generation is desired.
            print_flag: bool
                Should be set to True if the user wants the objective function values found in the optimization problem
                and False otherwise.
            numpy_dtype:
                The numpy data type used within the optimization routine. All variables in the optimization routine will
                be converted to this data type.
            concentration_bounds: list of tuples
                A list defining the lower and upper bounds for those species&#39; concentrations not in the decision vector.
                The user is not allowed to set the species&#39; concentration to a single value. See also:
                :func:`crnt4sbml.MassConservationApproach.get_concentration_bounds_species`.
            confidence_level_flag: bool
                If True a confidence level for the objective function will be given.
            change_in_rel_error: float
                The maximum relative error that should be allowed to consider :math:`f_k` in the neighborhood
                of :math:`\widetilde{f}`.
        Returns
        --------
        params_for_global_min: list of numpy arrays
            A list of numpy arrays that correspond to the decision vectors of the problem.
        obj_fun_val_for_params: list of floats
            A list of objective function values produced by the corresponding decision vectors in params_for_global_min.

        Examples
        ---------
        See :ref:`quickstart-deficiency-label` and :ref:`my-deficiency-label`.
        &quot;&quot;&quot;
        self.__numpy_dtype = numpy_dtype
        temp_c = numpy.zeros(self.__N, dtype=self.__numpy_dtype)

        # testing to see if there are any equalities in bounds
        equality_bounds_indices = []
        for i in range(len(bounds)):
            if not isinstance(bounds[i], tuple):
                equality_bounds_indices.append(i)

        # recasting user provided input to numpy_dtype
        for i in range(len(bounds)):
            bounds[i] = self.__numpy_dtype(bounds[i])
            
        for i in range(len(concentration_bounds)):
            concentration_bounds[i] = self.__numpy_dtype(concentration_bounds[i])

        if len(concentration_bounds) != len(self.__concentration_bounds_species):
            print(&quot;Concentration bounds is the incorrect length!&quot;)
            sys.exit()

        full_concentration_bounds = []
        for i in range(self.__N):
            if self.__concentration_pars[i] in self.__decision_vector_x:
                indx = self.__decision_vector_x.index(self.__concentration_pars[i])
                full_concentration_bounds.append(bounds[indx])
            else:
                indx = self.__concentration_bounds_species.index(self.__concentration_pars[i])
                full_concentration_bounds.append(concentration_bounds[indx])

        sys_min_val = self.__numpy_dtype(sys_min_val)

        params_for_global_min, obj_fun_val_for_params, self.__important_info = BistabilityFinder.run_optimization(
            bounds, iterations, sys_min_val, temp_c, self.__penalty_objective_func, self.__feasible_point_check,
            self.__objective_function_to_optimize, self.__final_constraint_check, seed, equality_bounds_indices,
            print_flag, numpy_dtype, full_concentration_bounds, confidence_level_flag, change_in_rel_error)

        return params_for_global_min, obj_fun_val_for_params</div>

<div class="viewcode-block" id="MassConservationApproach.run_mpi_optimization"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.run_mpi_optimization">[docs]</a>    def run_mpi_optimization(self, bounds=None, iterations=10, sys_min_val=numpy.finfo(float).eps, seed=0, print_flag=False,
                             numpy_dtype=numpy.float64, concentration_bounds=None, confidence_level_flag=False,
                             change_in_rel_error=1e-2):
        &quot;&quot;&quot;
        Function for running an mpi version of the optimization problem for the mass conservation approach.

        Parameters
        -----------
            bounds: list of tuples
                A list defining the lower and upper bounds for each variable in the decision vector. Here the reactions
                are allowed to be set to a single value.
            iterations: int
                The number of iterations to run the feasible point method.
            sys_min_val: float
                The value that should be considered zero for the optimization problem.
            seed: int
                Seed for the random number generator. None should be used if a random generation is desired.
            print_flag: bool
                Should be set to True if the user wants the objective function values found in the optimization problem
                and False otherwise.
            numpy_dtype:
                The numpy data type used within the optimization routine. All variables in the optimization routine will
                be converted to this data type.
            concentration_bounds: list of tuples
                A list defining the lower and upper bounds for those species&#39; concentrations not in the decision vector.
                The user is not allowed to set the species&#39; concentration to a single value. See also:
                :func:`crnt4sbml.MassConservationApproach.get_concentration_bounds_species`.
            confidence_level_flag: bool
                If True a confidence level for the objective function will be given.
            change_in_rel_error: float
                The maximum relative error that should be allowed to consider :math:`f_k` in the neighborhood
                of :math:`\widetilde{f}`.
        Returns
        --------
        params_for_global_min: list of numpy arrays
            A list of numpy arrays that correspond to the decision vectors of the problem.
        obj_fun_val_for_params: list of floats
            A list of objective function values produced by the corresponding decision vectors in params_for_global_min.
        my_rank: integer
            An integer corresponding to the rank assigned to the core within the routine.

        Examples
        ---------
        See :ref:`parallel-crnt4sbml-label`.
        &quot;&quot;&quot;
        self.__numpy_dtype = numpy_dtype
        temp_c = numpy.zeros(self.__N, dtype=self.__numpy_dtype)

        # testing to see if there are any equalities in bounds
        equality_bounds_indices = []
        for i in range(len(bounds)):
            if not isinstance(bounds[i], tuple):
                equality_bounds_indices.append(i)

        # recasting user provided input to numpy_dtype
        for i in range(len(bounds)):
            bounds[i] = self.__numpy_dtype(bounds[i])

        for i in range(len(concentration_bounds)):
            concentration_bounds[i] = self.__numpy_dtype(concentration_bounds[i])

        if len(concentration_bounds) != len(self.__concentration_bounds_species):
            print(&quot;Concentration bounds is the incorrect length!&quot;)
            sys.exit()

        full_concentration_bounds = []
        for i in range(self.__N):
            if self.__concentration_pars[i] in self.__decision_vector_x:
                indx = self.__decision_vector_x.index(self.__concentration_pars[i])
                full_concentration_bounds.append(bounds[indx])
            else:
                indx = self.__concentration_bounds_species.index(self.__concentration_pars[i])
                full_concentration_bounds.append(concentration_bounds[indx])

        sys_min_val = self.__numpy_dtype(sys_min_val)

        params_for_global_min, obj_fun_val_for_params, self.__important_info, self.__my_rank, self.__comm, self.__num_cores = BistabilityFinder.run_mpi_optimization(
            bounds, iterations, sys_min_val, temp_c, self.__penalty_objective_func, self.__feasible_point_check,
            self.__objective_function_to_optimize, self.__final_constraint_check, seed, equality_bounds_indices,
            print_flag, numpy_dtype, full_concentration_bounds, confidence_level_flag, change_in_rel_error)

        return params_for_global_min, obj_fun_val_for_params, self.__my_rank</div>

<div class="viewcode-block" id="MassConservationApproach.run_continuity_analysis"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.run_continuity_analysis">[docs]</a>    def run_continuity_analysis(self, species=None, parameters=None, dir_path=&quot;./num_cont_graphs&quot;,
                                print_lbls_flag=False, auto_parameters=None, plot_labels=None):
        &quot;&quot;&quot;
        Function for running the numerical continuation and bistability analysis portions of the mass conservation
        approach.

        Parameters
        ------------
            species: string
                A string stating the species that is the y-axis of the bifurcation diagram.
            parameters: list of numpy arrays
                A list of numpy arrays corresponding to the decision vectors that produce a small objective function
                value.
            dir_path: string
                A string stating the path where the bifurcation diagrams should be saved.
            print_lbls_flag: bool
                If True the routine will print the special points found by AUTO 2000 and False will not print any
                special points.
            auto_parameters: dict
                Dictionary defining the parameters for the AUTO 2000 run. Please note that one should **not** set
                &#39;SBML&#39; or &#39;ScanDirection&#39; in these parameters as these are automatically assigned. It is absolutely
                necessary to set PrincipalContinuationParameter in this dictionary. For more information on these
                parameters refer to :download:`AUTO parameters &lt;../auto2000_input.pdf&gt;`. &#39;NMX&#39; will default to
                10000 and &#39;ITMX&#39; to 100.
            plot_labels: list of strings
                A list of strings defining the labels for the x-axis, y-axis, and title. Where the first element
                is the label for x-axis, second is the y-axis label, and the last element is the title label. If
                you would like to use the default settings for some of the labels, simply provide None for that
                element.
        Returns
        ---------
            multistable_param_ind: list of integers
                A list of those indices in &#39;parameters&#39; that produce multistable plots.
            plot_specifications: list of lists
                A list whose elements correspond to the plot specifications of each element in multistable_param_ind.
                Each element is a list where the first element specifies the range used for the x-axis, the second
                element is the range for the y-axis, and the last element provides the x-y values and special point label
                for each special point in the plot.

        Example
        ---------
        See :ref:`quickstart-deficiency-label` and :ref:`my-deficiency-label`.
        &quot;&quot;&quot;
        # setting default values for AUTO
        if &#39;NMX&#39; not in auto_parameters.keys():
            auto_parameters[&#39;NMX&#39;] = 10000

        if &#39;ITMX&#39; not in auto_parameters.keys():
            auto_parameters[&#39;ITMX&#39;] = 100

        # making the directory if it doesn&#39;t exist
        if not os.path.isdir(dir_path):
            os.mkdir(dir_path)

        species_num = self.__species.index(species) + 1

        species_y = str(self.__concentration_pars[species_num-1])

        from .bistability_analysis import BistabilityAnalysis

        multistable_param_ind, important_info, plot_specifications = BistabilityAnalysis.run_continuity_analysis(species_num, parameters,
                                                                                                                 self.__initialize_ant_string,
                                                                                                                 self.__finalize_ant_string,
                                                                                                                 species_y, dir_path,
                                                                                                                 print_lbls_flag,
                                                                                                                 auto_parameters,
                                                                                                                 plot_labels)

        # multistable_param_ind, important_info, plot_specifications = BistabilityFinder.run_continuity_analysis(species_num, parameters,
        #                                                                                                        self.__initialize_ant_string,
        #                                                                                                        self.__finalize_ant_string,
        #                                                                                                        species_y, dir_path,
        #                                                                                                        print_lbls_flag,
        #                                                                                                        auto_parameters,
        #                                                                                                        plot_labels)

        self.__important_info += important_info

        return multistable_param_ind, plot_specifications</div>

<div class="viewcode-block" id="MassConservationApproach.run_greedy_continuity_analysis"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.run_greedy_continuity_analysis">[docs]</a>    def run_greedy_continuity_analysis(self, species=None, parameters=None, dir_path=&quot;./num_cont_graphs&quot;,
                                       print_lbls_flag=False, auto_parameters=None, plot_labels=None):
        &quot;&quot;&quot;
        Function for running the greedy numerical continuation and bistability analysis portions of the mass conservation
        approach. This routine uses the initial value of the principal continuation parameter to construct AUTO
        parameters and then tests varying fixed step sizes for the continuation problem. Note that this routine may
        produce jagged or missing sections in the plots provided. To produce better plots one should use the information
        provided by this routine to run :func:`crnt4sbml.MassConservationApproach.run_continuity_analysis`.

        Parameters
        ------------
            species: string
                A string stating the species that is the y-axis of the bifurcation diagram.
            parameters: list of numpy arrays
                A list of numpy arrays corresponding to the decision vectors that produce a small objective function
                value.
            dir_path: string
                A string stating the path where the bifurcation diagrams should be saved.
            print_lbls_flag: bool
                If True the routine will print the special points found by AUTO 2000 and False will not print any
                special points.
            auto_parameters: dict
                Dictionary defining the parameters for the AUTO 2000 run. Please note that only the
                PrincipalContinuationParameter in this dictionary should be defined, no other AUTO parameters should
                be set. For more information on these parameters refer to :download:`AUTO parameters &lt;../auto2000_input.pdf&gt;`.
            plot_labels: list of strings
                A list of strings defining the labels for the x-axis, y-axis, and title. Where the first element
                is the label for x-axis, second is the y-axis label, and the last element is the title label. If
                you would like to use the default settings for some of the labels, simply provide None for that
                element.
        Returns
        ---------
            multistable_param_ind: list of integers
                A list of those indices in &#39;parameters&#39; that produce multistable plots.
            plot_specifications: list of lists
                A list whose elements correspond to the plot specifications of each element in multistable_param_ind.
                Each element is a list where the first element specifies the range used for the x-axis, the second
                element is the range for the y-axis, and the last element provides the x-y values and special point label
                for each special point in the plot.

        Example
        ---------
        See :ref:`my-deficiency-label`.
        &quot;&quot;&quot;
        # setting default values for AUTO
        if &#39;NMX&#39; not in auto_parameters.keys():
            auto_parameters[&#39;NMX&#39;] = 10000

        if &#39;ITMX&#39; not in auto_parameters.keys():
            auto_parameters[&#39;ITMX&#39;] = 100

        # making the directory if it doesn&#39;t exist
        if not os.path.isdir(dir_path):
            os.mkdir(dir_path)

        species_num = self.__species.index(species) + 1

        species_y = str(self.__concentration_pars[species_num-1])

        from .bistability_analysis import BistabilityAnalysis

        multistable_param_ind, important_info, plot_specifications = BistabilityAnalysis.run_greedy_continuity_analysis \
            (species_num, parameters, self.__initialize_ant_string, self.__finalize_ant_string, species_y, dir_path,
             print_lbls_flag, auto_parameters, plot_labels)

        # multistable_param_ind, important_info, plot_specifications = BistabilityFinder.run_greedy_continuity_analysis\
        #     (species_num, parameters, self.__initialize_ant_string, self.__finalize_ant_string, species_y, dir_path,
        #      print_lbls_flag, auto_parameters, plot_labels)

        self.__important_info += important_info

        return multistable_param_ind, plot_specifications</div>

<div class="viewcode-block" id="MassConservationApproach.run_direct_simulation"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.run_direct_simulation">[docs]</a>    def run_direct_simulation(self, response=None, signal=None, params_for_global_min=None, dir_path=&quot;./&quot;, change_in_relative_error=1e-6,
                              parallel_flag=False, print_flag=False, left_multiplier=0.5, right_multiplier=0.5):

        &quot;&quot;&quot;
        Function for running direct simulation to conduct bistability analysis of the general approach.

        Note: This routine is more expensive than the numerical continuation routines, but can provide solutions
        when the Jacobian of the ODE system is always singular. A parallel version of this routine is available.

        Parameters
        ------------
            params_for_global_min: list of numpy arrays
                A list of numpy arrays corresponding to the input vectors that produce a small objective function
                value.
            dir_path: string
                A string stating the path where the bifurcation diagrams should be saved.
            change_in_relative_error: float
                A float value that determines how small the relative error should be in order for the solution of the
                ODE system to be considered at a steady state. Note: a smaller value will run faster, but may produce
                an ODE system that is not at a steady state.
            parallel_flag: bool
                If set to True a parallel version of direct simulation is ran. If False, a serial version of the
                routine is ran. See :ref:`parallel-gen-app-label` for further information.
            print_flag: bool
                If set to True information about the direct simulation routine will be printed. If False, no output
                will be provided.
            left_multiplier: float
                A float value that determines the percentage of the signal that will be searched to the left of the signal
                value. For example, the lowerbound for the signal range will be signal_value - signal_value*left_multiplier.
            right_multiplier: float
                A float value that determines the percentage of the signal that will be searched to the right of the signal
                value. For example, the upperbound for the signal range will be signal_value + signal_value*right_multiplier.

        Example
        ---------
        See :ref:`gen-app-label`.
        &quot;&quot;&quot;
        import scipy.integrate as itg

        self.__response = response
        self.__signal = signal
        self.__sympy_species = self.__concentration_pars
        self.__sympy_reactions = self.__reaction_pars
        self.__full_system = self.__cgraph.get_ode_system()

        self.__cons_laws_sympy = self.__cgraph.get_b() * sympy.Matrix([self.__concentration_pars]).T

        self.__cons_laws_sympy_lamb = [sympy.utilities.lambdify(self.__concentration_pars, self.__cons_laws_sympy[i])
                                 for i in range(len(self.__cons_laws_sympy))]

        conservation_constants = [&#39;C&#39; + str(i + 1) for i in range(len(self.__cons_laws_sympy))]
        self.__signal_index = conservation_constants.index(self.__signal)

        # params_for_global_min = [params_for_global_min[0]]
        # sys.exit()

        ########################################

        lambda_inputs = self.__sympy_reactions + self.__sympy_species
        self.__ode_lambda_functions = [sympy.utilities.lambdify(lambda_inputs, self.__full_system[i]) for i in
                                       range(len(self.__full_system))]

        self.__jac_lambda_function = sympy.utilities.lambdify(lambda_inputs, self.__full_system.jacobian(self.__sympy_species))

        self.__dir_sim_print_flag = print_flag

        spec_index = self.__sympy_species.index(sympy.Symbol(self.__response, positive=True))

        BistabilityAnalysis.run_direct_simulation(params_for_global_min, parallel_flag, dir_path, itg,
                                                  change_in_relative_error,
                                                  spec_index, left_multiplier, right_multiplier, self.__comm,
                                                  self.__my_rank, self.__num_cores, self.__dir_sim_print_flag,
                                                  self.__R, self.__N, self.__cons_laws_sympy_lamb,
                                                  self.__cons_laws_sympy, self.__sympy_species, self.__signal_index,
                                                  self.__signal, self.__response, self.__ode_lambda_functions,
                                                  self.__jac_lambda_function, self.__concentration_funs, &quot;MassConservationApproach&quot;)




        sys.exit()

        if parallel_flag is False and self.__comm is None:

            #making the directory if it doesn&#39;t exist
            if not os.path.isdir(dir_path):
                os.mkdir(dir_path)

            print(&quot;Starting direct simulation ...&quot;)
            start_t = time.time()

        elif parallel_flag is True and self.__comm is None:

                from mpi4py import MPI
                self.__comm = MPI.COMM_WORLD
                self.__my_rank = self.__comm.Get_rank()
                self.__num_cores = self.__comm.Get_size()
                self.__comm.Barrier()

                if not os.path.isdir(dir_path) and self.__my_rank == 0:
                    os.mkdir(dir_path)

                self.__comm.Barrier()

                start_time = MPI.Wtime()

                if self.__my_rank == 0:
                    print(&quot;Starting direct simulation ...&quot;)
        elif self.__comm is not None:

            from mpi4py import MPI

            if not os.path.isdir(dir_path) and self.__my_rank == 0:
                os.mkdir(dir_path)

            self.__comm.Barrier()

            params_for_global_min = self.__comm.bcast(params_for_global_min, root=0)

            self.__comm.Barrier()

            start_time = MPI.Wtime()

            if self.__my_rank == 0:
                print(&quot;Starting direct simulation ...&quot;)

        else:
            print(&quot;Starting direct simulation ...&quot;)
            start_t = time.time()

        if len(params_for_global_min) == 0:
            print(&quot;The parameter sets provided has a length of zero, direct simulation cannot be ran.&quot;)
            sys.exit()

        viable_indices, viable_out_values, conservation_vals = self.__find_viable_indices(params_for_global_min[0], itg, spec_index, change_in_relative_error)

        spec_index, fwd_scan_vals, rvrs_scan_vals, fwd_scan_index, rvrs_scan_index = self.__initialize_direct_simulation(viable_indices, viable_out_values,
                                                                                                                         params_for_global_min[0], conservation_vals, itg,
                                                                                                                         change_in_relative_error, spec_index, left_multiplier,
                                                                                                                                 right_multiplier)
        if self.__dir_sim_print_flag:
            if self.__comm is None:
                self.__print_initial_conditions(fwd_scan_vals, rvrs_scan_vals)
            else:
                if self.__my_rank == 0:
                    self.__print_initial_conditions(fwd_scan_vals, rvrs_scan_vals)

        plot_flag = True

        for i in range(len(params_for_global_min)):

            if self.__dir_sim_print_flag:
                if self.__comm is None:
                    print(f&quot;Conducting stability analysis of element {i} of the list provided ... &quot;)
                else:
                    if self.__my_rank == 0:
                        print(f&quot;Conducting stability analysis of element {i} of the list provided ... &quot;)

            # conservation_vals = [self.__cons_laws_sympy_lamb[ii](*tuple(params_for_global_min[i][self.__R:self.__R + self.__N]))
            #                      for ii in range(len(self.__cons_laws_sympy_lamb))]

            # conservation_vals = [self.__cons_laws_sympy_lamb[i](*tuple(result_x[self.__R:self.__R + self.__N]))
            #                      for i in range(len(self.__cons_laws_sympy_lamb))]                                     # TODO: line changed for mass conservation approach

            conservation_vals = [self.__cons_laws_sympy_lamb[ii](*tuple([self.__concentration_funs[j](*tuple(params_for_global_min[i])) for j in range(self.__N)]))
                                 for ii in range(len(self.__cons_laws_sympy_lamb))]

            con_law_value = conservation_vals[self.__signal_index]
            change_left = con_law_value * left_multiplier
            change_right = con_law_value * right_multiplier
            pcp_scan = numpy.linspace(con_law_value - change_left, con_law_value + change_right, 100)

            forward_scan, reverse_scan = self.__conduct_fwd_rvrs_scan(params_for_global_min[i], fwd_scan_vals,
                                                                      rvrs_scan_vals, pcp_scan, fwd_scan_index,
                                                                      rvrs_scan_index, spec_index, itg, change_in_relative_error)

            min_val, max_val = self.__get_min_max_vals(pcp_scan, forward_scan, reverse_scan)

            count = 0
            scan_vals = pcp_scan
            while count &lt; 5:
                if len([ii for ii in scan_vals if ii &gt;= min_val and ii &lt;= max_val]) &lt; 10:

                    second_scan = numpy.linspace(min_val, max_val, 60)

                    forward_scan, reverse_scan = self.__conduct_fwd_rvrs_scan(params_for_global_min[i], fwd_scan_vals,
                                                                              rvrs_scan_vals, second_scan, fwd_scan_index,
                                                                              rvrs_scan_index, spec_index, itg, change_in_relative_error)

                    min_val, max_val = self.__get_min_max_vals(second_scan, forward_scan, reverse_scan)
                    scan_vals = second_scan
                    count += 1
                else:
                    break

            if count == 0:
                second_scan = pcp_scan

            if plot_flag:

                if self.__comm is None:
                    self.__plot_direct_simulation(second_scan, forward_scan, reverse_scan, dir_path, i)
                else:
                    if self.__my_rank == 0:
                        self.__plot_direct_simulation(second_scan, forward_scan, reverse_scan, dir_path, i)


        if self.__comm is None:
            end_t = time.time()
            elapsed = end_t - start_t
            print(&quot;Elapsed time for direct simulation in seconds: &quot; + str(elapsed))
        else:
            self.__comm.Barrier()
            if self.__my_rank == 0:
                end_time = MPI.Wtime()
                elapsed = end_time - start_time
                print(f&quot;Elapsed time for direct simulation in seconds: {elapsed}&quot;)</div>

    def __find_viable_indices(self, result_x, itg, spec_index, change_in_relative_error):

        # conservation_vals = [self.__cons_laws_sympy_lamb[i](*tuple(result_x[self.__R:self.__R + self.__N]))
        #                      for i in range(len(self.__cons_laws_sympy_lamb))]                                       # TODO: line changed for mass conservation approach

        # conservation_vals = [self.__concentration_funs[j](*tuple(result_x)) for j in range(self.__N)]

        conservation_vals = [self.__cons_laws_sympy_lamb[i](*tuple([self.__concentration_funs[j](*tuple(result_x)) for j in range(self.__N)]))
                             for i in range(len(self.__cons_laws_sympy_lamb))]

        cons_laws_spec_info = []
        for i in self.__cons_laws_sympy:
            spec_in_law = [ii for ii in self.__sympy_species if ii in i.atoms()]
            spec_indices = [self.__sympy_species.index(ii) for ii in spec_in_law]
            coeff_of_spec = [i.coeff(ii, 1) for ii in spec_in_law]
            cons_laws_spec_info.append([coeff_of_spec, spec_indices])

        temp_comb = list(itertools.product(*[i[1] for i in cons_laws_spec_info]))

        all_unique_comb = [temp_comb[i] for i in range(len(temp_comb)) if len(set(temp_comb[i])) == len(temp_comb[i])]

        viable_indices = []
        viable_out_values = []
        for i in all_unique_comb:
            initial_species_values = [0.0 for i in range(self.__N)]

            for j in range(len(conservation_vals)):
                initial_species_values[i[j]] = conservation_vals[j]

            out = self.__steady_state_finder(initial_species_values, result_x, spec_index, itg, change_in_relative_error)
            steady_cons = [self.__cons_laws_sympy_lamb[i](*tuple(out)) for i in range(len(self.__cons_laws_sympy_lamb))]

            if not numpy.array_equal(numpy.array(initial_species_values), out):

                # accepting those indices that are smaller than a predescribed relative error
                if all([abs(conservation_vals[ii] - steady_cons[ii])/abs(steady_cons[ii]) &lt; change_in_relative_error for ii in range(len(conservation_vals))]):
                    viable_out_values.append(out)
                    viable_indices.append(i)
            elif len(out) == 2:

                # accepting those indices that are smaller than a predescribed relative error
                if all([abs(conservation_vals[ii] - steady_cons[ii]) / abs(steady_cons[ii]) &lt; change_in_relative_error
                        for ii in range(len(conservation_vals))]):
                    viable_out_values.append(out)
                    viable_indices.append(i)

        return viable_indices, viable_out_values, conservation_vals

    def __print_initial_conditions(self, fwd_scan_vals, rvrs_scan_vals):

        fwd_spec_inds = [i[0] for i in fwd_scan_vals]
        init_vals = []
        for i in range(self.__N):
            if i in fwd_spec_inds:
                init_vals.append(str(self.__sympy_species[i]) + &quot; = &quot; + &quot;C&quot; + str(fwd_spec_inds.index(i) + 1))
            else:
                init_vals.append(str(self.__sympy_species[i]) + &quot; = 0.0&quot;)

        print(&quot; &quot;)
        print(&quot;For the forward scan the following initial condition will be used:&quot;)
        for i in init_vals:
            print(i)

        rvrs_spec_inds = [i[0] for i in rvrs_scan_vals]
        init_vals = []
        for i in range(self.__N):
            if i in rvrs_spec_inds:
                init_vals.append(str(self.__sympy_species[i]) + &quot; = &quot; + &quot;C&quot; + str(rvrs_spec_inds.index(i) + 1))
            else:
                init_vals.append(str(self.__sympy_species[i]) + &quot; = 0.0&quot;)

        print(&quot; &quot;)
        print(&quot;For the reverse scan the following initial condition will be used:&quot;)
        for i in init_vals:
            print(i)
        print(&quot; &quot;)

    def __initialize_direct_simulation(self, viable_indices, viable_out_values, result_x, conservation_vals, itg,
                                       change_in_relative_error, spec_index, left_multiplier, right_multiplier):

        combos = list(itertools.combinations([i for i in range(len(viable_out_values))], 2))
        diff = [numpy.abs(viable_out_values[i[0]][spec_index] - viable_out_values[i[1]][spec_index]) for i in combos]
        maxpos = diff.index(max(diff))
        chosen_initial_combo = combos[maxpos]

        stop_flag = True
        while stop_flag:

            # selecting largest difference as the right pair
            maxpos = diff.index(max(diff))

            chosen_combo = combos[maxpos]

            fwd_scan_vals, rvrs_scan_vals, fwd_scan_index, rvrs_scan_index, fwd_ind, rvrs_ind = self.__get_important_scan_vals(chosen_combo,
                                                                                                                               spec_index,
                                                                                                                               viable_out_values,
                                                                                                                               viable_indices)

            # determining if the forward or reverse scan is constant, if so, remove it as a viable combination
            con_law_value = conservation_vals[self.__signal_index]
            # change = con_law_value*0.25
            # pcp_scan = numpy.linspace(con_law_value - change, con_law_value + change, 10)
            change_left = con_law_value * left_multiplier
            change_right = con_law_value * right_multiplier
            pcp_scan = numpy.linspace(con_law_value - change_left, con_law_value + change_right, 10)

            forward_scan, reverse_scan = self.__conduct_fwd_rvrs_scan(result_x, fwd_scan_vals,
                                                                      rvrs_scan_vals, pcp_scan, fwd_scan_index,
                                                                      rvrs_scan_index, spec_index, itg,
                                                                      change_in_relative_error)

            combos, diff, stop_flag, combos_flag = self.__get_new_combo(forward_scan, reverse_scan, fwd_ind, rvrs_ind, combos, diff)

            # if all combinations are thought to produce constant in time return the initial combo and continue
            if combos_flag:
                fwd_scan_vals, rvrs_scan_vals, fwd_scan_index, rvrs_scan_index, fwd_ind, rvrs_ind = self.__get_important_scan_vals(
                    chosen_initial_combo,
                    spec_index,
                    viable_out_values,
                    viable_indices)
                break

        return spec_index, fwd_scan_vals, rvrs_scan_vals, fwd_scan_index, rvrs_scan_index

    def __get_important_scan_vals(self, chosen_combo, spec_index, viable_out_values, viable_indices):

        # choosing the largest value at the species index as the &quot;high concentration&quot; option
        if viable_out_values[chosen_combo[0]][spec_index] &lt; viable_out_values[chosen_combo[1]][spec_index]:

            fwd_scan_vals = [[viable_indices[chosen_combo[1]][j], j] for j in
                             range(len(viable_indices[chosen_combo[1]]))]
            fwd_ind = chosen_combo[1]
            rvrs_scan_vals = [[viable_indices[chosen_combo[0]][j], j] for j in
                              range(len(viable_indices[chosen_combo[0]]))]
            rvrs_ind = chosen_combo[0]

        else:
            fwd_scan_vals = [[viable_indices[chosen_combo[0]][j], j] for j in
                             range(len(viable_indices[chosen_combo[0]]))]
            fwd_ind = chosen_combo[0]
            rvrs_scan_vals = [[viable_indices[chosen_combo[1]][j], j] for j in
                              range(len(viable_indices[chosen_combo[1]]))]
            rvrs_ind = chosen_combo[1]

        # index to change in forward scan
        fwd_scan_index = [i[0] for i in fwd_scan_vals if i[1] == self.__signal_index][0]
        # index to change in reverse scan
        rvrs_scan_index = [i[0] for i in rvrs_scan_vals if i[1] == self.__signal_index][0]

        return fwd_scan_vals, rvrs_scan_vals, fwd_scan_index, rvrs_scan_index, fwd_ind, rvrs_ind

    def __get_new_combo(self, forward_scan, reverse_scan, fwd_ind, rvrs_ind, combos, diff):

        constant_index = []
        reverse_scan = [abs(i) for i in reverse_scan]
        forward_scan = [abs(i) for i in forward_scan]

        fwd_rel_change = abs(max(forward_scan) - min(forward_scan)) / max(forward_scan)

        if fwd_rel_change &gt;= 0.98:
            constant_index.append(fwd_ind)

        rvrs_rel_change = abs(max(reverse_scan) - min(reverse_scan)) / max(reverse_scan)

        if rvrs_rel_change &gt;= 0.98:
            constant_index.append(rvrs_ind)

        #if one or both of them are deemed to be constant, then we throw out one or both from the combos.
        #Use fwd_ind and rvrs_ind to throw out combos that were constant, then redo process with new
        #combo being created. Continue until process with no constant combo is found. If all combos are eleminated
        #return the initial combo.
        if constant_index:
            ind_to_remove = [i for i in range(len(combos)) if combos[i][0] in constant_index or combos[i][1] in constant_index]
            combos = [combos[i] for i in range(len(combos)) if i not in ind_to_remove]
            diff = [diff[i] for i in range(len(diff)) if i not in ind_to_remove]

            if not combos:
                return combos, diff, True, True

            return combos, diff, True, False
        else:
            return combos, diff, False, False

    def __get_min_max_vals(self, pcp_scan, forward_scan, reverse_scan):

        fwd_diff = [abs(forward_scan[i] - forward_scan[i + 1]) for i in range(len(forward_scan) - 1)]

        fwd_maxpos = fwd_diff.index(max(fwd_diff))

        if fwd_maxpos == 0:
            fwd_maxpos = 1
        elif fwd_maxpos+2 == len(pcp_scan):
            fwd_maxpos = len(pcp_scan)-2

        fwd_pcp_scan = pcp_scan[fwd_maxpos - 1:fwd_maxpos + 2]

        rvrs_diff = [abs(reverse_scan[i] - reverse_scan[i + 1]) for i in range(len(reverse_scan) - 1)]

        rvrs_maxpos = rvrs_diff.index(max(rvrs_diff))

        if rvrs_maxpos == 0:
            rvrs_maxpos = 1
        elif rvrs_maxpos+2 == len(pcp_scan):
            rvrs_maxpos = len(pcp_scan)-2

        rvrs_pcp_scan = pcp_scan[rvrs_maxpos - 1:rvrs_maxpos + 2]

        min_val = min(list(fwd_pcp_scan) + list(rvrs_pcp_scan))

        max_val = max(list(fwd_pcp_scan) + list(rvrs_pcp_scan))

        return min_val, max_val

    def __conduct_fwd_rvrs_scan(self, result_x, fwd_scan_vals, rvrs_scan_vals, pcp_scan, fwd_scan_index,
                                rvrs_scan_index, spec_index, itg, change_in_relative_error):

        if self.__comm is not None:
            pcp_scan = self.__distribute_list_of_points(pcp_scan)

        # conservation_vals = [self.__cons_laws_sympy_lamb[i](*tuple(result_x[self.__R:self.__R + self.__N]))
        #                      for i in range(len(self.__cons_laws_sympy_lamb))]                                     # TODO: line changed for mass conservation approach

        conservation_vals = [self.__cons_laws_sympy_lamb[i](*tuple([self.__concentration_funs[j](*tuple(result_x)) for j in range(self.__N)]))
                             for i in range(len(self.__cons_laws_sympy_lamb))]



        initial_species_values = [0.0 for i in range(self.__N)]

        for i in fwd_scan_vals:
            initial_species_values[i[0]] = conservation_vals[i[1]]

        forward_scan = []
        for i in pcp_scan:
            initial_species_values[fwd_scan_index] = i
            steady_state = self.__steady_state_finder(initial_species_values, result_x, spec_index, itg, change_in_relative_error)
            forward_scan.append(steady_state[spec_index])

        initial_species_values = [0.0 for i in range(self.__N)]
        for i in rvrs_scan_vals:
            initial_species_values[i[0]] = conservation_vals[i[1]]

        reverse_scan = []
        for i in pcp_scan:
            initial_species_values[rvrs_scan_index] = i
            steady_state = self.__steady_state_finder(initial_species_values, result_x, spec_index, itg, change_in_relative_error)
            reverse_scan.append(steady_state[spec_index])

        if self.__comm is not None:
            list_forward_scan = self.__gather_list_of_values(forward_scan)
            list_reverse_scan = self.__gather_list_of_values(reverse_scan)

            list_forward_scan = self.__comm.bcast(list_forward_scan, root=0)
            list_reverse_scan = self.__comm.bcast(list_reverse_scan, root=0)

            self.__comm.Barrier()

            return list_forward_scan, list_reverse_scan

        else:
            return forward_scan, reverse_scan

    def __steady_state_finder(self, initial_species_values, result_x, spec_index, itg, change_in_relative_error):

        def ff(t, cs, ks, ode_lambda_functions, jacobian):
            return [i(*tuple(ks), *tuple(cs)) for i in ode_lambda_functions]

        def jac_f(t, cs, ks, ode_lambda_functions, jacobian):
            return jacobian(*tuple(ks), *tuple(cs))

        len_time_interval = 100.0

        with numpy.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
            out = itg.solve_ivp(ff, [0.0, len_time_interval], initial_species_values, args=(result_x[0:self.__R], self.__ode_lambda_functions, self.__jac_lambda_function), jac=jac_f, method=&#39;BDF&#39;, rtol=1e-6, atol=1e-9, vectorized=True) #&#39;RK45&#39;)  #&#39;LSODA&#39;)
            y0 = out.y[:, -1]

        flag = True

        i = 1
        while flag:
            tspan = [0.0 + i*len_time_interval, len_time_interval + i*len_time_interval]
            try:
                with numpy.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
                    out = itg.solve_ivp(ff, tspan, y0, args=(result_x[0:self.__R], self.__ode_lambda_functions, self.__jac_lambda_function), jac=jac_f, method=&#39;BDF&#39;, rtol=1e-6, atol=1e-9, vectorized=True) #&#39;RK45&#39;)  #&#39;LSODA&#39;)
                    y0 = out.y[:, -1]
                i += 1
            except Exception as e:
                flag = False

            # if there is a division by zero we exit the routine
            try:
                with warnings.catch_warnings():
                    warnings.simplefilter(&quot;ignore&quot;)
                    flag = abs(out.y[spec_index, -1] - out.y[spec_index, 0]) / abs(out.y[spec_index, -1]) &gt; change_in_relative_error and i &lt; 1000
            except Exception as e:
                flag = False

        return out.y[:, -1]

    def __plot_direct_simulation(self, pcp_scan, forward_scan, reverse_scan, path, index):

        import pandas
        from plotnine import ggplot, aes, geom_line, ylim, scale_color_distiller, facet_wrap, theme_bw, geom_path, \
            geom_point, labs, annotate
        from matplotlib import rc
        rc(&#39;text&#39;, usetex=True)

        out = pandas.DataFrame(columns=[&#39;dir&#39;, &#39;signal&#39;] + [self.__response])
        for i in range(len(forward_scan)):
            out_i = pandas.DataFrame([forward_scan[i]], columns=[out.columns[2]])
            out_i[&#39;signal&#39;] = pcp_scan[i]
            out_i[&#39;dir&#39;] = &#39;Forward scan&#39;
            out = pandas.concat([out, out_i[out.columns]])
        for i in range(len(reverse_scan)):
            out_i = pandas.DataFrame([reverse_scan[i]], columns=[out.columns[2]])
            out_i[&#39;signal&#39;] = pcp_scan[i]
            out_i[&#39;dir&#39;] = &#39;Reverse scan&#39;
            out = pandas.concat([out, out_i[out.columns]])

        g = (ggplot(out)
             + aes(x=&#39;signal&#39;, y=self.__response, color=&#39;dir&#39;)
             + labs(x=f&quot;{self.__signal} total&quot;, y=f&quot;[{self.__response}]&quot;, color=&quot;&quot;)
             + geom_path(size=2, alpha=0.5)
             + geom_point(color=&quot;black&quot;)
             + theme_bw()
             + geom_point(color=&quot;black&quot;))
        g.save(filename=path + f&quot;/sim_bif_diag_{index}.png&quot;, format=&quot;png&quot;, width=6, height=4, units=&#39;in&#39;, verbose=False)

    def __gather_list_of_values(self, values):

        full_values = self.__comm.gather(values, root=0)

        if self.__my_rank == 0:
            list_of_values = []
            for i in range(len(full_values)):
                list_of_values += full_values[i]
        else:
            list_of_values = []

        return list_of_values

    def __distribute_list_of_points(self, samples):

        if self.__my_rank == 0:

            # number of tasks per core
            tasks = len(samples) // self.__num_cores  # // calculates the floor

            # remainder
            r = len(samples) - self.__num_cores * tasks

            # array that holds how many tasks each core has
            tasks_core = numpy.zeros(self.__num_cores, dtype=numpy.int64)
            tasks_core.fill(tasks)

            # distributing in the remainder
            ii = 0
            while r &gt; 0:
                tasks_core[ii] += 1
                r -= 1
                ii += 1

            sample_portion = samples[0:tasks_core[0]]

            if self.__num_cores &gt; 1:
                for i in range(1, self.__num_cores):
                    start = sum(tasks_core[0:i])
                    end = start + tasks_core[i]
                    self.__comm.send(samples[start:end], dest=i, tag=i * 11)

        else:
            if self.__num_cores &gt; 1:
                sample_portion = self.__comm.recv(source=0, tag=self.__my_rank * 11)

        return sample_portion

<div class="viewcode-block" id="MassConservationApproach.generate_report"><a class="viewcode-back" href="../../classes/crnt4sbml.MassConservationApproach.html#crnt4sbml.MassConservationApproach.generate_report">[docs]</a>    def generate_report(self):
        &quot;&quot;&quot;
        Prints out helpful details constructed by :func:`crnt4sbml.MassConservationApproach.run_optimization` and
        :func:`crnt4sbml.MassConservationApproach.run_continuity_analysis`.

        Example
        --------
        See :ref:`quickstart-deficiency-label` and :ref:`my-deficiency-label`.
        &quot;&quot;&quot;

        if self.__comm == None:
            print(self.__important_info)
        else:

            all_important_info = self.__comm.gather(self.__important_info, root=0)
            self.__comm.Barrier()

            if self.__my_rank == 0:

                print(&quot;&quot;)

                for i in range(1, len(all_important_info)):
                    print(all_important_info[i])
                print(self.__important_info)</div>

    def __initialize_ant_string(self, species_num, pcp_x):
        y = self.__cgraph.get_y()
        a = self.__cgraph.get_a()
        bt = self.__cgraph.get_b()
        psi = self.__cgraph.get_psi()

        # forming ya matrix
        ya = y*a

        # finding how many rows are indep in ya
        _, vals = ya.T.rref()
        num_indp_eqns = len(vals)
        num_dep_eqns = ya.shape[0] - num_indp_eqns

        # getting dimensions of bt
        bt_rows = bt.shape[0]
        bt_cols = bt.shape[1]

        bt_nonzero_ind = []
        for i in range(bt_rows):
            bt_nonzero_ind.append([j for j in range(bt_cols) if bt[i, j] != 0 and j != species_num-1])

        chosen_indp_indices, chosen_dep_indices = self.__get_indp_dep_species_indices(bt_nonzero_ind, num_dep_eqns,
                                                                                      num_indp_eqns, ya)

        replacements, ind_spec_conc_temp, indp_odes_temp = self.__construct_important_variables(chosen_indp_indices,
                                                                                                chosen_dep_indices, ya,
                                                                                                psi, bt)

        ode_str = self.__create_ode_str(replacements, ind_spec_conc_temp, indp_odes_temp, species_num)

        return ode_str, pcp_x

    def __get_indp_dep_species_indices(self, bt_nonzero_ind, num_dep_eqns, num_indp_eqns, ya):
        # getting all combinations of the list indices
        possible_dep_species = list(itertools.product(*bt_nonzero_ind))

        removed_entries = []
        # remove tuples that have duplicate entries
        for i in range(len(possible_dep_species)):
            if len(set(possible_dep_species[i])) != num_dep_eqns:
                removed_entries.append(i)
        for index in sorted(removed_entries, reverse=True):
            del possible_dep_species[index]

        # get corresponding possible dependent species
        possible_indp_species = [] 
        species_ind = [i for i in range(len(self.__concentration_pars))]

        for i in possible_dep_species:
            possible_indp_species.append([j for j in species_ind if j not in i])

        # using YA to pick one of the possible indices
        chosen_indp_indices = []
        chosen_dep_indices = []
        for i in range(len(possible_indp_species)):
            _, vals = ya[possible_indp_species[i], :].T.rref()

            if len(vals) == num_indp_eqns: 
                chosen_indp_indices = possible_indp_species[i]
                chosen_dep_indices = possible_dep_species[i]
                break

        return chosen_indp_indices, chosen_dep_indices

    def __construct_important_variables(self, chosen_indp_indices, chosen_dep_indices, ya, psi, bt):
        # getting independent concentrations
        ind_spec_conc_temp = [self.__concentration_pars[i] for i in chosen_indp_indices]

        # getting dependent concentrations
        dep_spec_conc = [self.__concentration_pars[i] for i in chosen_dep_indices]

        # constructing the independent ODEs
        indp_odes_temp = ya[chosen_indp_indices, :] * psi

        # creating conservation laws string
        self.__cons_laws_sympy = bt*sympy.Matrix([self.__concentration_pars]).T

        # Lambda function of conservation laws
        self.__cons_laws_lamb = [sympy.utilities.lambdify(self.__concentration_pars, self.__cons_laws_sympy[i])
                                 for i in range(len(self.__cons_laws_sympy))]

        cons_laws_sympy_eq = [sympy.Eq(sympy.Symbol(&#39;C&#39; + str(i+1), real=True), self.__cons_laws_sympy[i])
                              for i in range(len(self.__cons_laws_sympy))]

        dep_conc_in_laws = self.__dependent_species_concentrations(self.__cons_laws_sympy, dep_spec_conc)
        
        replacements = self.__find_dep_concentration_replacements(dep_conc_in_laws, self.__cons_laws_sympy,
                                                                  dep_spec_conc, cons_laws_sympy_eq)

        return replacements, ind_spec_conc_temp, indp_odes_temp

    def __create_ode_str(self, replacements, ind_spec_conc_temp, indp_odes_temp, species_num):
        # rearrange ind_spec_conc and indp_odes to make species of
        # interest be the first ODE
        indx_species_num = ind_spec_conc_temp.index(self.__concentration_pars[species_num-1])

        self.__ind_spec_conc = [ind_spec_conc_temp[indx_species_num]]
        for i in ind_spec_conc_temp:
            if i != self.__concentration_pars[species_num-1]:
                self.__ind_spec_conc.append(i)

        indp_odes = sympy.zeros(indp_odes_temp.shape[0], indp_odes_temp.shape[1])
        indp_odes[0] = indp_odes_temp[indx_species_num]
        count = 1
        for i in range(indp_odes_temp.shape[0]):
            if i != indx_species_num:
                indp_odes[count] = indp_odes_temp[i]
                count += 1

        # bulding ODE string in Antimony format
        ode_str = self.__building_ode_str(replacements, self.__ind_spec_conc, indp_odes)

        return ode_str
        
    def __finalize_ant_string(self, x, ode_str):
        concentration_vals = [self.__concentration_funs[j](*tuple(x)) for j in range(self.__N)]

        kinetic_vals = [x[i] for i in range(self.__R)]

        antstr = self.__initialize_variables_in_antimony_string(self.__cons_laws_sympy, ode_str,
                                                                self.__cons_laws_lamb, concentration_vals, kinetic_vals,
                                                                self.__reaction_pars)
        print(antstr)                                                                                                      # TODO: add to print_flag
        return antstr

    def __final_constraint_check(self, x_initial, penalty_bounds, sys_min_val, equality_bounds_indices,
                                 concentration_bounds):
        non_equality_bounds_indices = [i for i in range(len(penalty_bounds)) if i not in equality_bounds_indices]

        x = numpy.zeros(len(penalty_bounds), dtype=self.__numpy_dtype)
        for j in equality_bounds_indices:              
            x[j] = penalty_bounds[j]              
        count = 0                                      
        for j in non_equality_bounds_indices:          
            x[j] = x_initial[count]                
            count += 1 

        # concentration &gt; 0 check
        con = numpy.asarray([self.__concentration_funs[j](*tuple(x)) for j in range(self.__N)],
                            dtype=self.__numpy_dtype)
        con_temp = []
        for i in range(self.__N):
            con_temp.append(con[i] &gt;= concentration_bounds[i][0] and con[i] &lt;= concentration_bounds[i][1])
        concs_chk = numpy.all(con_temp)

        # boundary check
        test = []
        for j in non_equality_bounds_indices: 
            test.append(x[j] &gt;= penalty_bounds[j][0] and x[j] &lt;= penalty_bounds[j][1])
        boundry_chk = numpy.all(test)

        # rank(G) = N + delta - 1 check
        # xx = numpy.concatenate((x[0:self.__R],con),axis=None)

        # must convert xx to numpy.float64 because higher
        # is not supported in linalg
        # xx = numpy.float64(xx)

        # rank_G = numpy.linalg.matrix_rank(self.__lambda_G_matrix(*tuple(xx)))
        # rank_G_chk = rank_G == (self.__N + self.__delta - 1)

        # rank(DCH) = min(N,M-ell) check
        # rank_DCH = numpy.linalg.matrix_rank(self.__lambda_DCH_matrix(*tuple(xx)))

        # rank_DCH_chk = rank_DCH == min(self.__N,self.__M - self.__ell)

        if concs_chk and boundry_chk:  # and rank_G_chk and rank_DCH_chk:
            
            return [True, x]
        else:
            
            return [False, []]

    def __concentration_violation_fun(self, g, len_g):
        temp = numpy.zeros(len_g, dtype=self.__numpy_dtype)
        for i in range(len_g):
            temp[i] = numpy.maximum(self.__numpy_dtype(0.0), -g[i])**2
        return temp

    def __x_violation_fun(self, x, b, len_x):
        temp = numpy.zeros(len_x, dtype=self.__numpy_dtype)
        for i in range(len_x):
            temp[i] = numpy.maximum(self.__numpy_dtype(0.0), self.__numpy_dtype(b)-x[i])**2
        return temp

    def __penalty_objective_func(self, x_initial, temp_c, penalty_bounds, equality_bounds_indices, x,
                                 non_equality_bounds_indices, concentration_bounds):

        for j in equality_bounds_indices:
            x[j] = penalty_bounds[j]
        count = 0 
        for j in non_equality_bounds_indices:
            x[j] = x_initial[count]
            count += 1 

        # evaluating the concentrations first
        for i in range(self.__N):
            temp_val = self.__concentration_funs[i](*tuple(x))

            if numpy.iscomplex(temp_val): 
                temp_c = numpy.array([numpy.Inf for i in range(self.__N)], dtype=self.__numpy_dtype)
                break
            else:
                with warnings.catch_warnings():
                    warnings.simplefilter(&quot;ignore&quot;, numpy.ComplexWarning)
                    temp_c[i] = temp_val 

        if numpy.all(numpy.isfinite(temp_c)):

            # obtaining the sum of the violation functions squared
            sumval = self.__numpy_dtype(0.0)
            for j in range(self.__N):
                sumval += numpy.maximum(self.__numpy_dtype(0.0), concentration_bounds[j][0]-temp_c[j])**2
                sumval += numpy.maximum(self.__numpy_dtype(0.0), temp_c[j] - concentration_bounds[j][1])**2

            sum0 = self.__numpy_dtype(0.0)
            for j in non_equality_bounds_indices: 
                sum0 += numpy.maximum(self.__numpy_dtype(0.0), penalty_bounds[j][0]-x[j])**2
                sum0 += numpy.maximum(self.__numpy_dtype(0.0), x[j] - penalty_bounds[j][1])**2
            sumval += sum0

            # obtaining the violation function values for
            # k&#39;s and concentrations in x
            # xx = numpy.concatenate((x[0:self.__R],x[self.__R + self.__alpha_end_ind:self.__d_len]),axis=None)
            # temp = self.__x_violation_fun(xx,self.__numpy_dtype(0.0),self.__R + (self.__d_len - (self.__R +
            # self.__alpha_end_ind)))
            # sumval += numpy.sum(temp)
            return sumval 

        else:
            return numpy.PINF

    def __feasible_point_check(self, x, result_fun, sys_min_val, equality_bounds_indices, non_equality_bounds_indices,
                               penalty_bounds, concentration_bounds):
        result_x = numpy.zeros(len(penalty_bounds), dtype=self.__numpy_dtype)

        for j in equality_bounds_indices:
            result_x[j] = penalty_bounds[j]
        count = 0
        for j in non_equality_bounds_indices:
            result_x[j] = x[count]
            count += 1

        # double checking the concentrations
        con = numpy.asarray([self.__concentration_funs[i](*tuple(result_x)) for i in range(self.__N)],
                            dtype=self.__numpy_dtype)
        con_temp = []
        for i in range(self.__N):
            con_temp.append(con[i] &gt;= concentration_bounds[i][0] and con[i] &lt;= concentration_bounds[i][1])
        concs_chk = numpy.all(con_temp)

        finite_chk = numpy.isfinite(con)
        if concs_chk and numpy.all(finite_chk):

            # putting the feasible points in x_candidates
            if abs(result_fun) &lt;= sys_min_val and numpy.all(con &gt; self.__numpy_dtype(0)):
                return True
            else:
                return False
        else:
            return False 
                
    def __objective_function_to_optimize(self, x_initial, temp_c, penalty_bounds, sys_min_val, equality_bounds_indices,
                                         x, non_equality_bounds_indices, concentration_bounds):
        for j in equality_bounds_indices:
            x[j] = penalty_bounds[j]
        count = 0
        for j in non_equality_bounds_indices:
            x[j] = x_initial[count]
            count += 1

        test = []
        for j in non_equality_bounds_indices:
            test.append(x[j] &gt;= penalty_bounds[j][0] and x[j] &lt;= penalty_bounds[j][1])
        boundry_chk = numpy.all(test)

        if boundry_chk:
            # calculating the concentration values
            for i in range(self.__N):
                temp_val = self.__concentration_funs[i](*tuple(x))
                if numpy.iscomplex(temp_val):
                    temp_c = numpy.array([numpy.Inf for i in range(self.__N)], dtype=self.__numpy_dtype)
                    break
                else:
                    with warnings.catch_warnings(): 
                        warnings.simplefilter(&quot;ignore&quot;, numpy.ComplexWarning)
                        temp_c[i] = temp_val 

            finite_chk = numpy.isfinite(temp_c)
            con_temp = []
            for i in range(self.__N):
                con_temp.append(temp_c[i] &gt;= concentration_bounds[i][0] and temp_c[i] &lt;= concentration_bounds[i][1])
            concs_chk = numpy.all(con_temp)
        # making sure our concentrations are finite
            if concs_chk and numpy.all(finite_chk): 
                temp = numpy.zeros(self.__N, dtype=self.__numpy_dtype)
                for i in range(self.__N):
                    temp[i] = numpy.maximum(self.__numpy_dtype(0.0), -temp_c[i])
                sumval = numpy.sum(temp)

                xx = numpy.concatenate((x[0:self.__R], temp_c), axis=None)
                return self.__lambda_objective_fun(*tuple(xx)) + sumval
            else:
                return numpy.PINF

        else:
            return numpy.PINF

    def __dependent_species_concentrations(self, cons_laws_sympy, dep_spec_conc):
        # finding those dep_spec_conc that occur in each conservation law
        dep_conc_in_laws = []
        for i in range(len(cons_laws_sympy)):
            temp = []
            for j in range(len(dep_spec_conc)):
                if cons_laws_sympy[i].count(dep_spec_conc[j]) &gt; 0:
                    temp.append(dep_spec_conc[j])
            dep_conc_in_laws.append(temp)
        return dep_conc_in_laws

    def __is_list_empty(self, inlist):
        if isinstance(inlist, list):  # Is a list
            return all(map(self.__is_list_empty, inlist))
        return False  # Not a list

    def __find_dep_concentration_replacements(self, dep_conc_in_laws, cons_laws_sympy, dep_spec_conc,
                                              cons_laws_sympy_eq):
        replacements = []
        flag = True
        while flag:
            for i in range(len(cons_laws_sympy_eq)):
                if len(dep_conc_in_laws[i]) == 1:
                    temp = sympy.solve(cons_laws_sympy_eq[i], dep_conc_in_laws[i])
                    cons_laws_sympy = [cons_laws_sympy[j].subs(dep_conc_in_laws[i][0], temp[0])
                                       for j in range(len(cons_laws_sympy))]

                    cons_laws_sympy_eq = [sympy.Eq(sympy.Symbol(&#39;C&#39; + str(i+1), real=True), cons_laws_sympy[i])
                                          for i in range(len(cons_laws_sympy))]

                    replacements.append([dep_conc_in_laws[i][0], &#39;(&#39; + str(temp[0]) + &#39;)&#39;])

            dep_conc_in_laws = self.__dependent_species_concentrations(cons_laws_sympy, dep_spec_conc)

            if self.__is_list_empty(dep_conc_in_laws):
                flag = False

        return replacements    

    def __building_ode_str(self, replacements, ind_spec_conc, indp_odes):
        indp_odes_str = []
        # making the replacements in the indep. ODEs
        for i in range(len(indp_odes)):
            for j in range(len(replacements)):
                indp_odes[i] = indp_odes[i].subs(replacements[j][0], replacements[j][1])
            indp_odes_str.append(str(indp_odes[i]))

        self.__independent_odes = indp_odes
        self.__independent_species = ind_spec_conc

        # replacing all powers with ^ instead of **
        for i in range(len(indp_odes_str)):
            indp_odes_str[i] = indp_odes_str[i].replace(&#39;**&#39;, &#39;^&#39;)

        # building the string of ODEs in Antimony syntax
        ode_str = &#39;&#39;
        for i in range(len(ind_spec_conc)):
            ode_str += &#39;J&#39; + str(i) + &#39;: -&gt; &#39; + str(ind_spec_conc[i]) + &#39;; &#39; + indp_odes_str[i] + &#39;;&#39;

        return ode_str

    def __building_ant_str(self, ode_str, kinetic_con, lhs_cons_laws, var_vals):
        vars_to_initialize = kinetic_con+lhs_cons_laws + [str(self.__concentration_pars[i]) for i in range(self.__N)]

        ant_str = ode_str

        for i in range(len(vars_to_initialize)):
            ant_str += str(vars_to_initialize[i]) + &#39; = &#39; + str(var_vals[i]) + &#39;;&#39;

        return ant_str

    def __initialize_variables_in_antimony_string(self, cons_laws_sympy, ode_str, cons_laws_lamb, concentration_vals,
                                                  kinetic_vals, kinetic_con):

        # string representation of variables on lhs of mass cons laws
        lhs_cons_laws = [&#39;C&#39;+str(i+1) for i in range(len(cons_laws_sympy))]

        conservation_law_vals = [cons_laws_lamb[i](*tuple(concentration_vals)) for i in range(len(cons_laws_lamb))]

        var_vals = kinetic_vals + conservation_law_vals + concentration_vals

        # The full Antimony string of system of ODEs
        ant_str = self.__building_ant_str(ode_str, kinetic_con, lhs_cons_laws, var_vals)

        return ant_str</div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, Brandon Reyes

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>